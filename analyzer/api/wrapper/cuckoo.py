import enum
import os.path
import requests
import urllib.parse

from upload import uploads_storage
from .utils import connect, build_cuckoo_api_path


class CuckooAPIHashSearchType(enum.Enum):
    SHA256 = "sha256"
    MD5 = "md5"
    ID = "id"


class CuckooAPIReportFormat(enum.Enum):
    JSON = "json"
    HTML = "pdf"
    ALL = "all"
    DROPPED = "dropped"
    PACKAGE_FILES = "package_files"


class CuckooAPIVmNotAvailable(Exception):

    def __int__(self, vm_name):
        Exception.__init__(self, "CuckooAPI: VM {0} not available!".format(vm_name))


class CuckooAPIFileNotFound(Exception):

    def __int__(self, file):
        Exception.__init__(self, "Cuckoo API: file not found at {0}".format(file))


class CuckooAPITaskNotFound(Exception):
    def __int__(self, task_id):
        Exception.__init__(self, "Cuckoo API: {0} non found".format(task_id))


class CuckooAPI(object):

    def __init__(self, host="127.0.0.1", port=8090, protocol="http", api_key=""):
        self.session = requests.Session()
        self.session.headers = {
            'Authorization': 'Bearer {}'.format(api_key)
        }
        self.host = host
        self.port = port
        self.protocol = protocol
        self.api_base_url = build_cuckoo_api_path(host, port, protocol)

    @staticmethod
    def create(self, host="127.0.0.1", port=8090, protocol="http"):
        if self.instance is None:
            self.instance = CuckooAPI(host, port, protocol)
        return self.instance

    def get_cuckoo_base_url(self):
        return self.api_base_url

    def get_cuckoo_host(self):
        return self.host

    def get_cuckoo_port(self):
        return self.port

    def get_cuckoo_protocol(self):
        return self.protcol

    def get_cuckoo_status(self):
        return connect(self.session, "GET", urllib.parse.urljoin(self.api_base_url, "cuckoo/status"))

    def get_cuckoo_machines(self):
        return connect(self.session, "GET", urllib.parse.urljoin(self.api_base_url, "machines/list"))

    def machines_detail(self, vm_name=None):

        if vm_name is None:
            raise CuckooAPIVmNotAvailable(vm_name)

        return connect(self.session, "GET",
                       urllib.parse.urljoin(self.api_base_url, "machines/view/{0}".format(vm_name)))

    def submit_file(self, file_name=None, data=None):

        if (file_name is None or not os.path.exists(file_name) or
                not os.path.isfile(file_name)):
            raise CuckooAPIFileNotFound(file_name)

        file = {"file": (file_name, uploads_storage.open(file_name, 'rb'))}

        json_request = connect(self.session, "POST", urllib.parse.urljoin(self.api_base_url, "tasks/create/file"),
                               data=data, files=file)

        return json_request

    def submit_url(self, url, data=None):

        url = {"url": ("", url)}

        return connect(self.session, "POST", urllib.parse.urljoin(self.api_base_url, "tasks/create/url"),
                       data=data, files=url)

    def task_view(self, task_id):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        return connect(self.session, "GET", urllib.parse.urljoin(self.api_base_url, "tasks/view{0}".format(task_id)))

    def task_report_summary(self, task_id):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        json_request = connect(self.session, "GET",
                               urllib.parse.urljoin(self.api_base_url, "tasks/summary/{0}".format(task_id)))

        if json_request is None:
            raise CuckooAPITaskNotFound(task_id)
        else:
            return json_request

    def task_report(self, task_id=None, report_format=CuckooAPIReportFormat.JSON):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        response = connect(self.session, "GET",
                           urllib.parse.urljoin(self.api_base_url,
                                                "tasks/report/{0}/{1}".format(task_id, report_format)))

        if report_format == CuckooAPIReportFormat.JSON:
            return response.text

    def task_screenshots(self, task_id=None, file_name="", screenshot=None):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        if file_name is None or os.path.exists(file_name):
            raise CuckooAPIFileNotFound(file_name)

        if screenshot is not None:
            screenshot = str(screenshot)

        file_name = file_name + ".zip"

        response = connect(self.session, "GET",
                           urllib.parse.urljoin(self.api_base_url,
                                                "tasks/screenshots/{0}/{1}".format(task_id, screenshot)),
                           stream=True)

        screen_file = uploads_storage.open(file_name, 'wb')

        for chunk in response.iter_content(chunk_size=1024):
            if chunk:
                screen_file.write(chunk)

    def task_delete(self, task_id=None):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        return connect(self.session, "GET", urllib.parse.urljoin(self.api_base_url, "tasks/delete/{0}".format(task_id)))

    def file_view(self, task_id: int, hash_type=CuckooAPIHashSearchType.ID):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        return connect(self.session, "GET",
                       urllib.parse.urljoin(self.api_base_url, "files/view/{0}/{1}".format(hash_type, task_id)))

    def memory_list(self, task_id: int):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        return connect(self.session, "GET", urllib.parse.urljoin(self.api_base_url, "memory/list/{0}".format(task_id)))

    def memory_get(self, task_id: int, number: str):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        return connect(self.session, "GET",
                       urllib.parse.urljoin(self.api_base_url, "memory/get/{0}/{1}".format(task_id, number)))

    def pcap_task_download(self, task_id, file_name=""):

        if task_id < 1 or task_id is None:
            raise CuckooAPITaskNotFound(task_id)

        if file_name is None or os.path.exists(file_name):
            raise CuckooAPIFileNotFound(file_name)

        response = connect(self.session, "GET",
                           urllib.parse.urljoin(self.api_base_url, "pcap/get/{0}".format(task_id)))

        pcap_dump = uploads_storage.open(file_name, 'wb')

        for chunk in response.iter_content(chunk_size=1024):
            pcap_dump.write(chunk)
